# -*- coding: utf-8 -*-
"""Hermiteipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rm9ve6STf2JN2_3QaDgjoeteUsS1S6Xz
"""

import numpy as np
import matplotlib.pyplot as plt
import math
def diferencias_divididas(x,y):
    n = len(x)
    tabla = np.zeros((n,n))
    tabla[:,0] = y # la primera columna es la f(x_i), 1<i<n
    for j in range(1,n): #el j itera sobre las columnas, arranco en 1 porque la 0 ya la sé
        for i in range(j,n): #la matriz es LOWER
            tabla[i][j] = (tabla[i][j-1]-tabla[i-1][j-1])/(x[i] - x[i-j])
    return tabla
x = np.array([-1,0,0,1,1])
y = np.array([3,2,2,3,3])


def hermite(x,y,fprima): #este codigo calcula la interpolacion de hermite si me ponen condiciones sobre la derivada primera:
  n = len(x)
  tabla = np.zeros((n,n))
  tabla[:,0] = y # la primera columna es la f(x_i), 1<i<n
  for j in range(1,n): #el j itera sobre las columnas, arranco en 1 porque la 0 ya la sé
      for i in range(j,n): #la matriz es LOWER
          denominador = (x[i] - x[i-j])
          if denominador ==0 and j==1: #si estas en la primera columna y da 0, haceme la primer derivada (la segunda condicion sirve mas para cuando haya mas derivadas que solo la primera)
            tabla[i][j]=fprima(x[i])
          else:
            tabla[i][j] = (tabla[i][j-1]-tabla[i-1][j-1])/denominador
  return tabla
#uso de ejemplo el que vimos en la practica, f(x) = sqrt(5x^2+4)
def fprima(x):
  return (10*x)/(2*np.sqrt((5*x**2+4)))
print(hermite(x,y,fprima)) #todo funca OK


#necesito un codigo para la interpolacion de hermite
def hermite_segundo(x,y,fprima,fsegunda): #este calcula si me ponen condiciones sobre la derivada segunda y sobre la primera:
  n = len(x)
  tabla = np.zeros((n,n))
  tabla[:,0] = y # la primera columna es la f(x_i), 1<i<n
  for j in range(1,n): #el j itera sobre las columnas, arranco en 1 porque la 0 ya la sé
      for i in range(j,n): #la matriz es LOWER
          denominador = (x[i] - x[i-j])
          if denominador==0:
            if j==1: #si estas en la primera columna y da 0, haceme la primer derivada
              tabla[i][j]=fprima(x[i])
            elif j==2: #si estas en la segunda columna, hace f''(x[i])/2!
              tabla[i][j]=fsegunda(x[i])/math.factorial(j)
          else:
            tabla[i][j] = (tabla[i][j-1]-tabla[i-1][j-1])/denominador
  return tabla
#pruebo con f(x) = x^8+1
def f_prima(x):
  return 8*x**7
def f_segunda(x):
  return 56*x**6
xx = [-1,-1,-1,0,0,0,1,1,1]
yy=[2,2,2,1,1,1,2,2,2]
A = (hermite_segundo(xx,yy,f_prima,f_segunda))

#una vez que tenes la matriz, necesito el polinomio
def polinomio_hermite(A,x,x_eval): #le metes la matriz de diferencias divididas (o la de hermite), los valores de x y un x_eval para evaluar al polinomio
  coeficientes = np.diag(A)
  print(coeficientes)
  evaluacion_total = coeficientes[0]
  producto = 1
  for i in range(1,len(coeficientes)):
    producto = producto*(x_eval-x[i-1])
    evaluacion_total += coeficientes[i]*producto
  return evaluacion_total
print(polinomio_hermite(A,xx,1)) #funciona OK